# -*- coding: utf-8 -*-
"""
Created on Thu Dec 18 16:51:17 2025

@author: navar
"""

# -*- coding: utf-8 -*-
r"""
EEG – Paso 2 (NoStimArtifact_1000Hz_aa.fif) — versión ROBUSTA

- Lee runs directamente de:
  C:\Users\navar\Desktop\sub-P01\sub-P01\eeg_1000Hz_noStimArt\

- Combina bads manuales (PSD) + RMS auto
- Interpola SOLO EEG (safe) y revierte si mete NaN/Inf
- Filtra 0.5–45 Hz excluyendo triggers/markers por nombre
- Guarda:
  eeg_step2_clean_concat_05_45\eeg_allblocks_05_45.fif
  bad_eeg_channels_final.csv
"""

from pathlib import Path
import re
import numpy as np
import pandas as pd
import mne

# ==========================
# Paths (TU CASO REAL)
# ==========================
BASE = Path(r"C:\Users\navar\Desktop\sub-P01\sub-P01")

IN_DIR  = BASE / "eeg_1000Hz_noStimArt"
OUT_DIR = BASE / "eeg_step2_clean_concat_05_45"
OUT_DIR.mkdir(exist_ok=True, parents=True)

BAD_PSD_CSV   = BASE / "bad_eeg_channels_from_psd_clicks.csv"
BAD_FINAL_CSV = BASE / "bad_eeg_channels_final.csv"

SUBJECT_ID = "sub-P01"

# ==========================
# Tus 62 canales EEG reales
# ==========================
EEG_CHANNELS = [
    "Fp1", "Fz", "F3", "F7", "FT9", "FC5", "FC1", "C3", "T7", "TP9",
    "CP5", "CP1", "Pz", "P3", "P7", "O1", "Oz", "O2", "P4", "P8",
    "TP10", "CP6", "CP2", "C4", "T8", "FT10", "FC6", "FC2", "F4", "F8",
    "Fp2", "AF7", "AF3", "AFz", "F1", "F5", "FT7", "FC3", "C1", "C5",
    "TP7", "CP3", "P1", "P5", "PO7", "PO3", "POz", "PO4", "PO8", "P6",
    "P2", "CPz", "CP4", "TP8", "C6", "C2", "FC4", "FT8", "F6", "AF8",
    "AF4", "F2"
]

# ==========================
# Diagnóstico NaN/Inf
# ==========================
def assert_finite(raw, tag=""):
    x = raw.get_data()
    if np.isfinite(x).all():
        print(f"✅ [{tag}] sin NaN/Inf")
        return True

    mask = ~np.isfinite(x)
    ch_idx = np.where(mask.any(axis=1))[0]
    print(f"\n❌ [{tag}] NaN/Inf detectado en {len(ch_idx)} canales")
    for i in ch_idx:
        bad_pos = np.where(mask[i])[0]
        print(f"   - {raw.ch_names[i]}: {len(bad_pos)} muestras (primera={bad_pos[0]}, última={bad_pos[-1]})")
    raise ValueError(f"array must not contain infs or NaNs  --> [{tag}]")

# ==========================
# PSD manual bads (solo este sujeto)
# ==========================
def load_bad_from_psd_for_subject(subj: str):
    if not BAD_PSD_CSV.exists():
        print("⚠ No PSD CSV → sin malos manuales.")
        return []

    df = pd.read_csv(BAD_PSD_CSV)
    if "subject" not in df.columns or "bad_channels" not in df.columns:
        print("⚠ PSD CSV sin columnas esperadas.")
        return []

    df_sub = df[df["subject"].astype(str).str.strip() == subj]
    bad = set()
    for bc in df_sub["bad_channels"].tolist():
        if isinstance(bc, str) and bc.strip():
            bad.update([c.strip() for c in bc.split(";") if c.strip()])
    return sorted(bad)

# ==========================
# RMS auto (solo EEG reales)
# ==========================
def detect_bad_by_rms(raw, eeg_names, factor=5.0):
    picks = mne.pick_channels(raw.ch_names, include=eeg_names)
    if len(picks) == 0:
        return []

    data = raw.get_data(picks=picks)
    rms = np.sqrt(np.mean(data ** 2, axis=1))
    med = np.median(rms)
    if med == 0:
        return []

    bad_idx = np.where(rms > factor * med)[0]
    return [raw.ch_names[picks[i]] for i in bad_idx]

# ==========================
# Runs (directo en IN_DIR)
# ==========================
def find_runs():
    files = sorted(IN_DIR.glob("*Run*_NoStimArtifact*_1000Hz_aa.fif"))
    if not files:
        files = sorted(IN_DIR.glob("*NoStimArtifact*_1000Hz_aa.fif"))
    return files

# ==========================
# Paso 2
# ==========================
def step2_clean_and_concat(rms_factor=5.0):
    fif_files = find_runs()
    if not fif_files:
        raise FileNotFoundError(f"No matching *NoStimArtifact*_1000Hz_aa.fif in {IN_DIR}")

    print(f"Encontrados {len(fif_files)} runs en {IN_DIR}")

    manual_bad = load_bad_from_psd_for_subject(SUBJECT_ID)
    if manual_bad:
        print(f"Manual bad (PSD) {SUBJECT_ID}: {manual_bad}")

    raws = []
    auto_bad_all = []

    # ---- leer runs
    for fif in fif_files:
        print(f"\nLoading {fif.name}")
        raw_block = mne.io.read_raw_fif(fif, preload=True, verbose="warning")

        # sanity: por si ya viniera algo raro
        assert_finite(raw_block, tag=f"after_read {fif.name}")

        eeg_present = [ch for ch in EEG_CHANNELS if ch in raw_block.ch_names]
        bad_rms = detect_bad_by_rms(raw_block, eeg_present, factor=rms_factor)
        if bad_rms:
            print(f" → Auto RMS bad: {bad_rms}")
            auto_bad_all.extend(bad_rms)

        raws.append(raw_block)

    # ---- concatenar
    print("\n→ Concatenating blocks...")
    raw = mne.concatenate_raws(raws)
    assert_finite(raw, tag="after_concatenate")

    # ---- asegurar tipos EEG (si venían como misc)
    mapping = {ch: "eeg" for ch in EEG_CHANNELS if ch in raw.ch_names}
    if mapping:
        raw.set_channel_types(mapping)

    # ---- montage (para interpolación)
    montage = mne.channels.make_standard_montage("standard_1020")
    raw.set_montage(montage, on_missing="ignore")

    # ---- combinar bads
    auto_bad = sorted(set(auto_bad_all))
    combined_bad = sorted(set(manual_bad + auto_bad))
    combined_bad = [c for c in combined_bad if (c in raw.ch_names and c in EEG_CHANNELS)]

    if combined_bad:
        print(f"\n→ Final bad EEG: {combined_bad}")
        raw.info["bads"] = combined_bad
    else:
        print("\n→ No EEG bads.")

    # ---- interpolación SAFE (solo EEG) y revertir si mete NaN/Inf
        # ---- interpolación SAFE (solo EEG, compatible con MNE antiguo)
    if combined_bad:
        all_eeg = [ch for ch in EEG_CHANNELS if ch in raw.ch_names]
        good = [ch for ch in all_eeg if ch not in combined_bad]

        if len(good) < 4:
            print("  ⚠ Too few good EEG channels → skip interpolation.")
        else:
            print("  → Interpolating bad EEG channels (SAFE, no picks=)...")

            # Copia completa para poder revertir si algo sale mal
            raw_before = raw.copy()

            # Sanity check previo
            assert_finite(raw, tag="before_interpolate_bads")

            try:
                # 1) Copia SOLO EEG
                raw_eeg = raw.copy().pick(all_eeg)

                # 2) Marcar bads e interpolar (sin picks=)
                raw_eeg.info["bads"] = combined_bad
                raw_eeg.interpolate_bads(reset_bads=False)

                # 3) Volcar SOLO los canales interpolados al raw completo
                for ch in combined_bad:
                    if ch in raw.ch_names and ch in raw_eeg.ch_names:
                        raw._data[
                            raw.ch_names.index(ch), :
                        ] = raw_eeg._data[
                            raw_eeg.ch_names.index(ch), :
                        ]

            except Exception as e:
                print(f"  ⚠ Interpolation crashed: {e} → REVERT")
                raw = raw_before

            # Sanity check posterior
            try:
                assert_finite(raw, tag="after_interpolate_bads")
            except ValueError:
                print("  ⚠ Interpolation introduced NaN/Inf → REVERT")
                raw = raw_before


    # ---- filtro evitando triggers/markers por nombre
    exclude = [ch for ch in raw.ch_names if re.search(r"(stim|sti|trig|trigger|marker)", ch, re.I)]
    picks = [ch for ch in raw.ch_names if ch not in exclude]

    assert_finite(raw, tag="before_filter")
    print(f"\n→ Filtering 0.5–45 Hz (excluding {len(exclude)} trigger-like channels)...")
    raw.filter(
        l_freq=0.5,
        h_freq=45.0,
        method="iir",
        iir_params=dict(order=4, ftype="butter"),
        phase="zero",
        picks=picks,
        verbose="error",
    )
    assert_finite(raw, tag="after_filter")

    # ---- guardar
    out_path = OUT_DIR / "eeg_allblocks_05_45.fif"
    raw.save(out_path, overwrite=True)
    print("\n✔ Saved:", out_path)

    pd.DataFrame([{
        "subject": SUBJECT_ID,
        "bad_channels": ";".join(combined_bad)
    }]).to_csv(BAD_FINAL_CSV, index=False)
    print(f"✔ Final bad channels CSV saved → {BAD_FINAL_CSV}")

if __name__ == "__main__":
    step2_clean_and_concat(rms_factor=5.0)
