# -*- coding: utf-8 -*-
r"""
EEG – Paso 2 (para tu salida NoStimArtifact_1000Hz_aa.fif)

Objetivo:
  ✔ Conservar TODOS los canales (EEG + otros)
  ✔ Detectar canales EEG malos (manual PSD + auto RMS)
  ✔ Interpolar SOLO esos EEG malos
  ✔ Filtrar 0.5–45 Hz sin borrar canales no EEG
  ✔ Guardar eeg_allblocks_05_45.fif por sujeto
"""

from pathlib import Path
import re
import numpy as np
import pandas as pd
import mne

# ==========================
# Paths (TU ESTRUCTURA)
# ==========================
BASE = Path(r"C:\Users\navar\Desktop")

IN_DIR  = BASE / "eeg_1000Hz_noStimArt"              # <- donde guardaste *_1000Hz_aa.fif
OUT_DIR = BASE / "eeg_step2_clean_concat_05_45"
OUT_DIR.mkdir(exist_ok=True, parents=True)

BAD_PSD_CSV   = BASE / "bad_eeg_channels_from_psd_clicks.csv"
BAD_FINAL_CSV = BASE / "bad_eeg_channels_final.csv"

# ==========================
# Tus 62 canales EEG reales (exactos)
# ==========================
EEG_CHANNELS = [
    "Fp1", "Fz", "F3", "F7", "FT9", "FC5", "FC1", "C3", "T7", "TP9",
    "CP5", "CP1", "Pz", "P3", "P7", "O1", "Oz", "O2", "P4", "P8",
    "TP10", "CP6", "CP2", "C4", "T8", "FT10", "FC6", "FC2", "F4", "F8",
    "Fp2", "AF7", "AF3", "AFz", "F1", "F5", "FT7", "FC3", "C1", "C5",
    "TP7", "CP3", "P1", "P5", "PO7", "PO3", "POz", "PO4", "PO8", "P6",
    "P2", "CPz", "CP4", "TP8", "C6", "C2", "FC4", "FT8", "F6", "AF8",
    "AF4", "F2"
]

# ==========================
# Cargar malos manuales del PSD
# (tu CSV actual suele tener columnas: subject, run, file, bad_channels)
# -> aquí agregamos por sujeto
# ==========================
def load_bad_from_psd():
    if not BAD_PSD_CSV.exists():
        print("⚠ No PSD CSV → sin malos manuales.")
        return {}

    df = pd.read_csv(BAD_PSD_CSV)

    if "subject" not in df.columns or "bad_channels" not in df.columns:
        print("⚠ PSD CSV no tiene columnas esperadas (subject, bad_channels).")
        return {}

    bad_dict = {}
    for _, r in df.iterrows():
        subj = str(r["subject"]).strip()
        bc = r["bad_channels"]

        if isinstance(bc, str) and bc.strip():
            chans = [c.strip() for c in bc.split(";") if c.strip()]
        else:
            chans = []

        bad_dict.setdefault(subj, set()).update(chans)

    return {k: sorted(v) for k, v in bad_dict.items()}

# ==========================
# Detección RMS automática (solo EEG reales)
# ==========================
def detect_bad_by_rms(raw, eeg_names, factor=5.0):
    picks = mne.pick_channels(raw.ch_names, include=eeg_names)
    if len(picks) == 0:
        return []

    data = raw.get_data(picks=picks)
    rms = np.sqrt(np.mean(data ** 2, axis=1))
    med = np.median(rms)

    if med == 0:
        return []

    bad_idx = np.where(rms > factor * med)[0]
    return [raw.ch_names[picks[i]] for i in bad_idx]

# ==========================
# Encontrar runs NoStimArtifact ya filtrados + 1000Hz
# ==========================
def find_runs(subj_dir: Path):
    # Solo los que vienen de NoStimArtifact y son la salida *_1000Hz_aa.fif
    return sorted(subj_dir.glob("*NoStimArtifact*_1000Hz_aa.fif"))

# ==========================
# Pipeline principal
# ==========================
def step2_clean_and_concat(subjects=None, rms_factor=5.0):
    """
    subjects:
      - None -> detecta carpetas sub-* dentro de IN_DIR
      - o lista/tupla: ("sub-P01", "sub-P02", ...)
    """
    bad_psd_dict = load_bad_from_psd()
    final_bad_rows = []

    if subjects is None:
        subj_dirs = sorted([p for p in IN_DIR.glob("sub-*") if p.is_dir()])
        subjects = [p.name for p in subj_dirs]

    for subj in subjects:
        subj_dir = IN_DIR / subj
        fif_files = find_runs(subj_dir)

        if not fif_files:
            print(f"{subj}: no matching *NoStimArtifact*_1000Hz_aa.fif files.")
            continue

        print(f"\n===== {subj} =====")

        raws = []
        auto_bad_all = []

        for fif in fif_files:
            print(f"  Loading {fif.name}")
            raw_block = mne.io.read_raw_fif(fif, preload=True, verbose="warning")

            # EEG existentes en ESTE archivo (de tu lista de 62)
            eeg_present = [ch for ch in EEG_CHANNELS if ch in raw_block.ch_names]

            # Auto RMS solo en EEG
            bad_rms = detect_bad_by_rms(raw_block, eeg_present, factor=rms_factor)
            if bad_rms:
                print(f"   → Auto RMS bad: {bad_rms}")
                auto_bad_all.extend(bad_rms)

            raws.append(raw_block)

        # Concatenar todos los bloques (conservando todos los canales)
        print("  → Concatenating blocks...")
        raw = mne.concatenate_raws(raws)

        # (Recomendado) set montage para que interpolate_bads funcione bien
        try:
            montage = mne.channels.make_standard_montage("standard_1020")
            raw.set_montage(montage, on_missing="ignore")
        except Exception as e:
            print(f"  ⚠ No pude setear montage (se intenta seguir igual): {e}")

        # Combinar manual + auto (por sujeto)
        manual_bad = bad_psd_dict.get(subj, [])
        auto_bad = sorted(set(auto_bad_all))
        combined_bad = sorted(set(manual_bad + auto_bad))

        # Quedarnos SOLO con EEG reales y que existan
        combined_bad = [c for c in combined_bad if (c in raw.ch_names and c in EEG_CHANNELS)]

        if combined_bad:
            print(f"  → Final bad EEG for {subj}: {combined_bad}")
            raw.info["bads"] = combined_bad
        else:
            print("  → No EEG bads for this subject.")

        # Interpolar SOLO si hay suficientes EEG buenos
        if combined_bad:
            all_eeg = [ch for ch in EEG_CHANNELS if ch in raw.ch_names]
            good = [ch for ch in all_eeg if ch not in combined_bad]
            if len(good) < 4:
                print("  ⚠ Too few good EEG channels → skip interpolation.")
            else:
                print("  → Interpolating EEG bad channels...")
                raw.interpolate_bads(reset_bads=False)

        # Filtrado global (sin borrar canales no EEG)
        print("  → Filtering 0.5–45 Hz (all channels)...")
        raw.filter(
            l_freq=0.5,
            h_freq=45.0,
            method="iir",
            iir_params=dict(order=4, ftype="butter"),
            phase="zero",
            picks="all",
            verbose="error",
        )

        # Guardar
        out_sub = OUT_DIR / subj
        out_sub.mkdir(exist_ok=True, parents=True)
        out_path = out_sub / "eeg_allblocks_05_45.fif"
        raw.save(out_path, overwrite=True)
        print("  ✔ Saved:", out_path)

        final_bad_rows.append({
            "subject": subj,
            "bad_channels": ";".join(combined_bad)
        })

    if final_bad_rows:
        pd.DataFrame(final_bad_rows).to_csv(BAD_FINAL_CSV, index=False)
        print(f"\n✔ Final bad channels CSV saved → {BAD_FINAL_CSV}")
    else:
        print("\nNo subjects processed → no final CSV.")


if __name__ == "__main__":
    # Para tu caso directo:
    step2_clean_and_concat(subjects=("sub-P01",), rms_factor=5.0)

    # Si luego quieres todos los que existan en IN_DIR:
    # step2_clean_and_concat(subjects=None, rms_factor=5.0)
