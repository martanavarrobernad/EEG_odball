# -*- coding: utf-8 -*-
"""
Created on Thu Dec 18 17:03:34 2025

@author: navar
"""

# -*- coding: utf-8 -*-
r"""
STEP 3B — Selección de ICs con correlaciones EOG/ECG (tipo SASICA) — ADAPTADO

- Usa VEOG y HEOG REALES (no proxies)
- Usa ECG real
- Alinea sfreq/longitud antes de correlacionar
- Fuentes ICA se calculan sobre raw_eeg con EXACTAMENTE ica.ch_names
- Guardado a bad_ica_components.csv

INPUT:
  raw: C:\Users\navar\Desktop\sub-P01\sub-P01\eeg_step2_clean_concat_05_45\eeg_allblocks_05_45.fif
  ica: C:\Users\navar\Desktop\sub-P01\sub-P01\eeg_step3_ica\ica_fitted_sr250Hz.fif

OUTPUT:
  C:\Users\navar\Desktop\sub-P01\sub-P01\bad_ica_components.csv
"""

from pathlib import Path
from math import ceil
import numpy as np
import pandas as pd
import mne
import matplotlib.pyplot as plt

# ==========================
# PATHS (TU CASO REAL)
# ==========================
BASE = Path(r"C:\Users\navar\Desktop\sub-P01\sub-P01")

IN_DATA = BASE / "eeg_step2_clean_concat_05_45" / "eeg_allblocks_05_45.fif"
IN_ICA_DIR = BASE / "eeg_step3_ica"
OUT_CSV = BASE / "bad_ica_components.csv"

# ==========================
# CANALES REALES (ajusta si tu raw los llama distinto)
# ==========================
ECG_CH_NAME  = "ECG"
VEOG_CH_NAME = "VEOG"
HEOG_CH_NAME = "HEOG"

DEFAULT_CORR_THRESH = 0.30
N_SD_ECG = 1.0
N_SD_EOG = 4.0

# ==========================
# UTILS
# ==========================
def _safe_corr(x, y) -> float:
    x = np.asarray(x, float).ravel()
    y = np.asarray(y, float).ravel()
    if x.size == 0 or y.size == 0 or x.size != y.size:
        return 0.0
    if np.std(x) == 0 or np.std(y) == 0:
        return 0.0
    r = np.corrcoef(x, y)[0, 1]
    if np.isnan(r):
        return 0.0
    return float(r)

def _get_signal(raw, ch):
    if ch not in raw.ch_names:
        return None
    return raw.get_data(picks=[ch])[0]

def _find_ica_file(ica_dir: Path) -> Path | None:
    candidates = sorted(ica_dir.glob("ica_fitted*.fif"))
    if not candidates:
        candidates = sorted([p for p in ica_dir.glob("*.fif") if "ica" in p.name.lower()])
    return candidates[0] if candidates else None

def load_raw_and_ica():
    if not IN_DATA.exists():
        raise FileNotFoundError(f"No raw: {IN_DATA}")

    ica_path = _find_ica_file(IN_ICA_DIR)
    if ica_path is None or not ica_path.exists():
        raise FileNotFoundError(f"No ICA in: {IN_ICA_DIR}")

    print(f" → Loading raw: {IN_DATA.name}")
    raw = mne.io.read_raw_fif(IN_DATA, preload=True, verbose="warning")

    print(f" → Loading ICA: {ica_path.name}")
    ica = mne.preprocessing.read_ica(ica_path, verbose="warning")

    return raw, ica, ica_path

def make_raw_eeg_from_ica(raw, ica):
    ica_chs = list(ica.ch_names)
    missing = [ch for ch in ica_chs if ch not in raw.ch_names]
    if missing:
        raise RuntimeError(f"Canales de ICA no presentes en raw: {missing}")

    raw_eeg = raw.copy().pick(ica_chs)  # mismo orden que ICA

    montage = mne.channels.make_standard_montage("standard_1020")
    raw_eeg.set_montage(montage, on_missing="ignore")
    return raw_eeg

def build_reference_signals(raw_full, target_sfreq: float):
    raw_ref = raw_full.copy()

    picks = [ch for ch in (ECG_CH_NAME, VEOG_CH_NAME, HEOG_CH_NAME) if ch in raw_ref.ch_names]
    if picks:
        raw_ref.pick(picks)

    if abs(raw_ref.info["sfreq"] - target_sfreq) > 1e-6:
        raw_ref.resample(target_sfreq, npad="auto")

    ecg  = _get_signal(raw_ref, ECG_CH_NAME)
    veog = _get_signal(raw_ref, VEOG_CH_NAME)
    heog = _get_signal(raw_ref, HEOG_CH_NAME)

    return ecg, veog, heog

def suggest_bad_ics_by_corr(raw_full, raw_eeg, ica,
                            corr_thresh=DEFAULT_CORR_THRESH,
                            n_sd_ecg=N_SD_ECG,
                            n_sd_eog=N_SD_EOG):

    print("\n → Computing IC correlations with ECG / VEOG / HEOG (aligned)...")

    # sfreq del ICA: en MNE antiguo puede no existir; usamos sfreq del raw_eeg
    sfreq_ica = raw_eeg.info["sfreq"]
    if hasattr(ica, "info") and isinstance(getattr(ica, "info", None), dict):
        sfreq_ica = ica.info.get("sfreq", sfreq_ica) or sfreq_ica

    raw_eeg_aligned = raw_eeg
    if abs(raw_eeg_aligned.info["sfreq"] - sfreq_ica) > 1e-6:
        raw_eeg_aligned = raw_eeg_aligned.copy().resample(sfreq_ica, npad="auto")

    ecg_sig, veog_sig, heog_sig = build_reference_signals(raw_full, target_sfreq=sfreq_ica)

    src = ica.get_sources(raw_eeg_aligned).get_data()
    n_ic, n_samp = src.shape

    def _clip(sig):
        if sig is None:
            return None
        sig = np.asarray(sig).ravel()
        if sig.size > n_samp:
            return sig[:n_samp]
        if sig.size < n_samp:
            return None
        return sig

    ecg_sig  = _clip(ecg_sig)
    veog_sig = _clip(veog_sig)
    heog_sig = _clip(heog_sig)

    corr_ecg  = np.zeros(n_ic)
    corr_veog = np.zeros(n_ic)
    corr_heog = np.zeros(n_ic)

    for i in range(n_ic):
        if ecg_sig is not None:
            corr_ecg[i] = _safe_corr(src[i], ecg_sig)
        if veog_sig is not None:
            corr_veog[i] = _safe_corr(src[i], veog_sig)
        if heog_sig is not None:
            corr_heog[i] = _safe_corr(src[i], heog_sig)

    def _auto_bad(corr_vec, n_sd):
        a = np.abs(corr_vec)
        m = a.mean()
        s = a.std()
        if s == 0:
            return np.array([], dtype=int), m, s, np.inf
        thr = m + n_sd * s
        idx = np.where(a > thr)[0]
        return idx, m, s, thr

    bad_ecg_sd,  m_ecg, s_ecg, thr_ecg = _auto_bad(corr_ecg,  n_sd_ecg)
    bad_veog_sd, m_v,   s_v,   thr_v   = _auto_bad(corr_veog, n_sd_eog)
    bad_heog_sd, m_h,   s_h,   thr_h   = _auto_bad(corr_heog, n_sd_eog)

    bad_ecg_abs  = np.where(np.abs(corr_ecg)  >= corr_thresh)[0]
    bad_veog_abs = np.where(np.abs(corr_veog) >= corr_thresh)[0]
    bad_heog_abs = np.where(np.abs(corr_heog) >= corr_thresh)[0]

    bad_ecg  = np.unique(np.concatenate([bad_ecg_sd,  bad_ecg_abs])).astype(int)
    bad_veog = np.unique(np.concatenate([bad_veog_sd, bad_veog_abs])).astype(int)
    bad_heog = np.unique(np.concatenate([bad_heog_sd, bad_heog_abs])).astype(int)

    print("\n=== IC correlations ===")
    print("IC\tcorr_ECG\tcorr_VEOG\tcorr_HEOG")
    for i in range(n_ic):
        print(f"{i:02d}\t{corr_ecg[i]: .3f}\t\t{corr_veog[i]: .3f}\t\t{corr_heog[i]: .3f}")

    print("\n=== Thresholds ===")
    print(f"  corr_thresh abs = {corr_thresh:.2f}")
    print(f"  ECG  SD-thr: mean={m_ecg:.3f} sd={s_ecg:.3f} -> thr={thr_ecg:.3f}")
    print(f"  VEOG SD-thr: mean={m_v:.3f}   sd={s_v:.3f}   -> thr={thr_v:.3f}")
    print(f"  HEOG SD-thr: mean={m_h:.3f}   sd={s_h:.3f}   -> thr={thr_h:.3f}")

    print("\n=== Suggested ICs ===")
    print(f"  Cardiaco (ECG):  {bad_ecg.tolist()}")
    print(f"  Ocular (VEOG):   {bad_veog.tolist()}")
    print(f"  Ocular (HEOG):   {bad_heog.tolist()}")

    return bad_ecg, bad_veog, bad_heog

def plot_ic_topomaps(ica, raw_eeg):
    components = ica.get_components()
    n_ch, n_ic = components.shape

    n_cols = 5
    n_rows = ceil(n_ic / n_cols)

    fig, axes = plt.subplots(n_rows, n_cols, figsize=(3.0 * n_cols, 3.0 * n_rows))
    axes = np.atleast_1d(axes).ravel()

    print(" → Plotting IC topographies...")

    for ic_idx in range(n_ic):
        ax = axes[ic_idx]
        topo = components[:, ic_idx]
        mne.viz.plot_topomap(
            data=topo,
            pos=raw_eeg.info,
            ch_type="eeg",
            sensors=True,
            contours=0,
            cmap="RdBu_r",
            outlines="head",
            axes=ax,
            show=False,
        )
        ax.set_title(f"IC {ic_idx}", fontsize=8)

    for ax in axes[n_ic:]:
        ax.axis("off")

    fig.suptitle("ICA topographies", fontsize=14)
    plt.tight_layout()
    plt.show()

def make_raw_view_for_traces(raw_eeg, win_len=20.0, target_sfreq=200.0):
    duration = raw_eeg.times[-1]
    if duration <= win_len:
        raw_view = raw_eeg.copy()
    else:
        mid = duration / 2.0
        tmin = max(0.0, mid - win_len / 2.0)
        tmax = min(duration, mid + win_len / 2.0)
        raw_view = raw_eeg.copy().crop(tmin=tmin, tmax=tmax)

    if raw_view.info["sfreq"] > target_sfreq + 1e-6:
        print(f" → Resampling EEG view {raw_view.info['sfreq']:.1f} → {target_sfreq:.1f} Hz")
        raw_view.resample(target_sfreq, npad="auto")

    return raw_view

def plot_ic_traces(ica, raw_view):
    print(" → Plotting IC time series (short window)...")
    plt.ioff()
    fig = ica.plot_sources(raw_view, show_scrollbars=True)
    plt.show(block=True)
    plt.close(fig)

# ==========================
# MAIN
# ==========================
def step3b_mark_bad_ics(corr_thresh=DEFAULT_CORR_THRESH):
    raw, ica, ica_path = load_raw_and_ica()

    raw_eeg = make_raw_eeg_from_ica(raw, ica)

    bad_ecg, bad_veog, bad_heog = suggest_bad_ics_by_corr(
        raw_full=raw,
        raw_eeg=raw_eeg,
        ica=ica,
        corr_thresh=corr_thresh,
        n_sd_ecg=N_SD_ECG,
        n_sd_eog=N_SD_EOG,
    )

    plot_ic_topomaps(ica, raw_eeg)

    raw_view = make_raw_view_for_traces(raw_eeg, win_len=20.0, target_sfreq=200.0)
    plot_ic_traces(ica, raw_view)

    suggested_union = sorted(set(bad_ecg) | set(bad_veog) | set(bad_heog))

    print("\nIntroduce los índices de ICs que quieres marcar como MALOS.")
    print(f"Sugeridos (union): {suggested_union}")
    print("Ejemplo: 0, 1, 7   | ENTER = aceptar sugeridos")
    txt = input("ICs malos para sub-P01: ").strip()

    if txt:
        manual = {int(t.strip()) for t in txt.split(",") if t.strip() != ""}
        bad_ics = sorted(manual)
    else:
        bad_ics = suggested_union

    print(f" → ICs finales marcados como malos: {bad_ics}")

    df = pd.DataFrame([{
        "subject": "sub-P01",
        "ica_file": ica_path.name,
        "bad_ics": ";".join(str(ic) for ic in bad_ics),
        "suggested_union": ";".join(str(ic) for ic in suggested_union),
        "corr_thresh": corr_thresh,
        "ecg_ch": ECG_CH_NAME if ECG_CH_NAME in raw.ch_names else "",
        "veog_ch": VEOG_CH_NAME if VEOG_CH_NAME in raw.ch_names else "",
        "heog_ch": HEOG_CH_NAME if HEOG_CH_NAME in raw.ch_names else "",
    }])
    df.to_csv(OUT_CSV, index=False)
    print(f"\n✔ Saved bad ICs to: {OUT_CSV}")

if __name__ == "__main__":
    step3b_mark_bad_ics(corr_thresh=0.30)
